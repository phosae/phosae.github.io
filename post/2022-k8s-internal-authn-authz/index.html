<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>K8s Internal Authentication/Authorization and mTLS - ZengXu&#39;s BLOG</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Zeng Xu" /><meta name="description" content="K8s Internal Authentication/Authorization and mTLS" /><meta name="keywords" content="kubernetes, mtls, ssl, auth, x509" />






<meta name="generator" content="Hugo 0.109.0 with theme even" />


<link rel="canonical" href="https://www.zeng.dev/post/2022-k8s-internal-authn-authz/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.3ab191e0444a0833d62fa8f1e44231fc793f2c04a2474a8b9348894c550f8388.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="K8s Internal Authentication/Authorization and mTLS" />
<meta property="og:description" content="K8s Internal Authentication/Authorization and mTLS" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.zeng.dev/post/2022-k8s-internal-authn-authz/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-01T16:13:12+08:00" />
<meta property="article:modified_time" content="2023-06-03T16:13:12+08:00" />
<meta itemprop="name" content="K8s Internal Authentication/Authorization and mTLS">
<meta itemprop="description" content="K8s Internal Authentication/Authorization and mTLS"><meta itemprop="datePublished" content="2022-08-01T16:13:12+08:00" />
<meta itemprop="dateModified" content="2023-06-03T16:13:12+08:00" />
<meta itemprop="wordCount" content="2468">
<meta itemprop="keywords" content="kubernetes,mtls,ssl,auth,x509,en," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="K8s Internal Authentication/Authorization and mTLS"/>
<meta name="twitter:description" content="K8s Internal Authentication/Authorization and mTLS"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Zeng Xu&#39;s BLOG</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="https://www.notion.so/zengxu/Zeng-Xu-s-Little-World-a6b002fb4d134333abe74a4e0491cea7">
        <li class="mobile-menu-item">杂文</li>
      </a><a href="/about">
        <li class="mobile-menu-item">我</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Zeng Xu&#39;s BLOG</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://www.notion.so/zengxu/Zeng-Xu-s-Little-World-a6b002fb4d134333abe74a4e0491cea7">杂文</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about">我</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">K8s Internal Authentication/Authorization and mTLS</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-01 16:13 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#kube-apiserver-authn-and-authz">kube-apiserver authn and authz</a></li>
    <li><a href="#authn-and-authz-in-other-components">authn and authz in other components</a></li>
    <li><a href="#components-reqeuests-kube-apisever">components reqeuests kube-apisever</a></li>
    <li><a href="#kubelet-requests-kube-apiserver">kubelet requests kube-apiserver</a></li>
    <li><a href="#kube-apiserver-requests-kubelet">kube-apiserver requests kubelet</a></li>
    <li><a href="#kubelet-x509-cert-distribution">kubelet x509 cert distribution</a></li>
    <li><a href="#3rd-application-requests-kubelet">3rd application requests kubelet</a></li>
    <li><a href="#kube-apiserver-as-a-front-proxy-kube-aggregation">kube-apiserver as a front proxy (kube-aggregation)</a></li>
    <li><a href="#service-account">service account</a></li>
    <li><a href="#mtls-between-etcd-and-kube-apiserver">mTLS between etcd and kube-apiserver</a></li>
    <li><a href="#summarize">Summarize</a></li>
    <li><a href="#furthur-reading">Furthur Reading</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="kube-apiserver-authn-and-authz">kube-apiserver authn and authz</h2>
<div class="mermaid">---
title: K8s API server's access authentication, authorization and admision control
---
flowchart LR

X509-Client-Certs & token & password --> N{1.authn}

N --> |has<br/>identity| user
N --> |401 Unauthorized<br/>has no identity| endx((return))

user --> Z{2.authz}

Z --> |has<br/>permission| C{3.admission<br/>control}
Z --> |403 Forbiden<br/>has no permission| endx

C --> |allow| to-API
C --> |deny 4xx| endx
</div>
<p>Once TLS is established, the HTTP request moves to the Authentication (authn) step.</p>
<p>Credentials, such as client certificates, tokens, and passwords, are used in this process. As described in <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">K8s Doc: Authenticating</a>, Kubernetes supports severals authentication plugins. In most cases, the kube-apiserver is configured to authenticate API requests through x509 client certificates, bootstrap tokens and service account tokens. Other strategies, like static token file (mostly used in testing), OpenID Connect tokens, authenticating proxy, and webhook are also configurable.</p>
<p><strong>If the request cannot be authenticated, it is rejected with HTTP status code 401.</strong>
<strong>Otherwise, the request is authenticated as coming from a specific user.</strong>
In the context of X509 client certificates, which are primarily covered in this post, the common name of the subject is used as the username for the request. The certificate&rsquo;s organization fields are used to determine the user&rsquo;s group memberships.</p>
<p>Following authentication, the HTTP request moves to the Authorization (authz) step. This involves the user of the requester, the requested action, and the object affected by the action. The user&rsquo;s permissions are interpreted by server&rsquo;s authorizers.</p>
<p>User&rsquo;s permissions can be granted by multiple polices, including role-based access control (RBAC), Node Authorization, Webhook and attribute-based access control (ABAC).</p>
<p>If an existing policy states that the user has permissions to complete the requested action, the request is authorized and proceeds to admission control step. Otherwise, the request is denied (HTTP status code 403).</p>
<p>Admission control is not covered by this post. For more details, please refer to my post <a href="../2023-k8s-api-admission">K8s API Admission Control and Policy</a>.</p>
<h2 id="authn-and-authz-in-other-components">authn and authz in other components</h2>
<p>Other components, such as kubelet, third-party apiservers, can delegate authentication to the kube-apiserver using the webhook authentication strategy with <a href="https://github.com/kubernetes/api/blob/5d126b39754e30ad9a9206307e95f569ffe887ec/authentication/v1/types.go#L52">authentication.k8s.io/TokenReview</a>.
They can also delegate authorization to the kube-apiserver using the webhook authorization mode with <a href="https://github.com/kubernetes/api/blob/5d126b39754e30ad9a9206307e95f569ffe887ec/authorization/v1/types.go#L31">authorization.k8s.io/SubjectAccessReview</a>.</p>
<p>Components can implement additional authentication strategies as needed.
For instance, a custom apiserver&rsquo;s authentication can support using the kube-apiserver as a front-proxy,
and the kubelet server&rsquo;s authentication support x509 client certificates.</p>
<p>Generally, the kube-apiserver acts as the authority control center of the cluster.
It grants permissions to all users through RBAC and Node Authorization.
In some cases, ABAC and webhook may also be used.
Other components should always delegate authorization to the kube-apiserver.</p>
<p>Let&rsquo;s take the controller manager, scheduler and third-party apiserver as generic examples</p>
<ul>
<li><code>authentication-kubeconfig</code> configures the crenditial used to send an <a href="https://github.com/kubernetes/api/blob/5d126b39754e30ad9a9206307e95f569ffe887ec/authentication/v1/types.go#L52">authentication.k8s.io/TokenReview</a> to kube-apiserver for authentication</li>
<li><code>authorization-kubeconfig</code> configures the crenditial used to send an <a href="https://github.com/kubernetes/api/blob/5d126b39754e30ad9a9206307e95f569ffe887ec/authorization/v1/types.go#L31">authorization.k8s.io/SubjectAccessReview</a> to kube-apiserver for authorization</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># common options in kube-controller-manager, kube-scheduler and 3rd apiserver</span>
</span></span><span class="line"><span class="cl">--authentication-kubeconfig string
</span></span><span class="line"><span class="cl">    kubeconfig file pointing at the <span class="s1">&#39;core&#39;</span> kubernetes server with enough rights to create
</span></span><span class="line"><span class="cl">    tokenreviews.authentication.k8s.io. This is optional. 
</span></span><span class="line"><span class="cl">    If empty, all token requests are considered to be anonymous and no client CA is looked up in the cluster.
</span></span><span class="line"><span class="cl">--authorization-kubeconfig string
</span></span><span class="line"><span class="cl">    kubeconfig file pointing at the <span class="s1">&#39;core&#39;</span> kubernetes server with enough rights to create
</span></span><span class="line"><span class="cl">    subjectaccessreviews.authorization.k8s.io. This is optional. 
</span></span><span class="line"><span class="cl">    If empty, all requests not skipped by authorization are forbidden.
</span></span></code></pre></td></tr></table>
</div>
</div><div class="mermaid">flowchart LR

server[kube-controller-manager<br/>kube-scheduler<br/>3rd-apiserver ]

3rd-app --> |serviceaccount token| server

server <--> |authn| kube-apiserver
server <--> |authz| kube-apiserver
</div>
<h2 id="components-reqeuests-kube-apisever">components reqeuests kube-apisever</h2>
<p>The <code>client-ca-file</code> option in kube-apiserver is used to set up the Certificate Authority (CA) for client certificates.
This CA is responsible for validating client certificates from components such as kubelet, kube-controller-manager, and others.</p>
<p>Typically, this CA is referred to as the <code>cluster CA</code>.</p>
<p>The server certificate for kube-apiserver is configured using the <code>tls-cert-file</code> and <code>tls-private-key-file</code> options.</p>
<p>Components that send requests to kube-apiserver can do the following:</p>
<ul>
<li>verify the server certificate by its pulic CA (as specified in kubeconfig&rsquo;s clusters field)</li>
<li>authenticate to the kube-apiserver using a client certificate (as specified in kubeconfig&rsquo;s users field)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">clusters:
</span></span><span class="line"><span class="cl">- cluster:
</span></span><span class="line"><span class="cl">    certificate-authority: path/to/apiserver/ca.crt
</span></span><span class="line"><span class="cl">    server: https://myapiserver.zeng.dev:6443
</span></span><span class="line"><span class="cl">  name: my-cluster
</span></span><span class="line"><span class="cl">kind: Config
</span></span><span class="line"><span class="cl">users:
</span></span><span class="line"><span class="cl">- name: foo
</span></span><span class="line"><span class="cl">  user:
</span></span><span class="line"><span class="cl">    client-certificate: path/to/my/client/cert 
</span></span><span class="line"><span class="cl">    client-key: path/to/my/client/key
</span></span></code></pre></td></tr></table>
</div>
</div><p>The CA of kube-apiserver&rsquo;s server certificate and the CA of component&rsquo;s client certificates don&rsquo;t need to be the same.</p>
<p>Generally they&rsquo;re the same.</p>
<div class="mermaid">flowchart LR

kube-controller-manager & kube-scheduler --> |x509 client certificate identified<br/>as user granted required permissions| kube-apiserver
3rd-apiserver/3rd-controller/etc --> |serviceaccount token| kube-apiserver

kube-apiserver <---> |authn/authz| kube-apiserver
</div>
<p>The kube-apiserver performs authentication and authorization on the credentials of component applications. This process requires:</p>
<ul>
<li>The credentials to identify them as a specific user in the cluster (typically a special user in the x509 client certificate or a service account user in the cluster)</li>
<li>The authenticated user to have permission to perform actions on cluster resources</li>
</ul>
<p>There are some examples</p>
<ul>
<li>The kube-scheduler requests the kube-apiserver with an x509 client certificate&rsquo;s subject common name as  <code>system:kube-schedule</code></li>
<li>The kube-controller-manager requests the kube-apiserver with an x509 client certificate&rsquo;s subject common name as <code>system:kube-controller-manager</code></li>
<li>The kube-proxy requests the kube-apiserver with an x509 client certificate&rsquo;s subject common name as <code>system:kube-proxy</code></li>
<li>Kubectl, with an admin config, requests the kube-apiserver with an x509 client certificate&rsquo;s subject organization as <code>system:masters</code></li>
<li>A third-party apiserver requests the kube-apiserver with a service account token that has been granted permissions</li>
</ul>
<p>Well-known user and group names can be found at <a href="https://github.com/kubernetes/apiserver/blob/master/pkg/authentication/user/user.go#L70-L85">k8s.io/apiserver/pkg/authentication/user/user.go</a></p>
<h2 id="kubelet-requests-kube-apiserver">kubelet requests kube-apiserver</h2>
<div class="mermaid">flowchart LR

kubelet --> |provides credential identified<br/>in group system:nodes<br/>with a username system:node:<_nodeName_>| kube-apiserver

kube-apiserver <---> |authn/authz| kube-apiserver
</div>
<p>The kube-apiserver authenticates requests from the kubelet. Any credential supported by the kube-apiserver is acceptable.</p>
<p>Kubernetes uses a <a href="https://kubernetes.io/docs/reference/access-authn-authz/node/">special-purpose authorization mode</a> called Node Authorizer, that specifically authorizes API requests made by kubelets.</p>
<p>To be authorized by the Node Authorizer, kubelets must use a credential that identifies them as part of the <code>system:nodes</code> group, with a username of <code>system:node:&lt;nodeName&gt;</code>.</p>
<p>Typically, the kubelet&rsquo;s credential is an x509 client certificate issued by the cluster CA.
The certificate&rsquo;s subject organization is <code>system:nodes</code>, and its subject common name is <code>system:node:&lt;nodeName&gt;</code>.</p>
<h2 id="kube-apiserver-requests-kubelet">kube-apiserver requests kubelet</h2>
<div class="mermaid">flowchart LR

kube-apiserver --> |1.x509 client certificate identified<br/>as user granted required permissions| kubelet

kubelet <--> |2.authn| kubelet
kubelet <--> |3.authz| kube-apiserver
</div>
<p>The kube-apiserver is configured with the following options:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--kubelet-certificate-authority string      Path to a cert file <span class="k">for</span> the certificate authority.
</span></span><span class="line"><span class="cl">--kubelet-client-certificate string         Path to a client cert file <span class="k">for</span> TLS.
</span></span><span class="line"><span class="cl">--kubelet-client-key string                 Path to a client key file <span class="k">for</span> TLS.
</span></span></code></pre></td></tr></table>
</div>
</div><p>The kubelet configures its options in a config file:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">kubelet.config.k8s.io/v1beta1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">KubeletConfiguration</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">authentication</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">anonymous</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">webhook</span><span class="p">:</span><span class="w">          </span><span class="c"># delegate authn to kube-apiserver. </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">   </span><span class="c"># for example, Prometheus provides serviceaccount token when scrape metrics</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">x509</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">clientCAFile</span><span class="p">:</span><span class="w"> </span><span class="l">/etc/kubernetes/pki/ca.crt</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">authorization</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">mode</span><span class="p">:</span><span class="w"> </span><span class="l">Webhook</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The kubelet and kube-apiserver use mutual TLS (mTLS) to verify each other:</p>
<ul>
<li>Kubelet verify kube-apiserver&rsquo;s client certificate is issued by the required CA (<code>authentication.x509.clientCAFile</code>).</li>
<li>Kube-apiserver verify kubelet&rsquo;s server certificate is issued by the required CA (<code>kubelet-certificate-authority</code>).</li>
</ul>
<p>Typically, these two CAs are the same. Both of them are the cluster CA.</p>
<p>The kubelet authenticates to the kube-apiserver, assuming its user identity is provided in the client certificate (with the subject organization as the group and the common name as the username).</p>
<p>For authorization, the kubelet sends an <a href="https://github.com/kubernetes/api/blob/5d126b39754e30ad9a9206307e95f569ffe887ec/authorization/v1/types.go#L31">authorization.k8s.io/SubjectAccessReview</a> to the kube-apiserver.
And yes, kube-apiserver check its own permissions by looking up the policy bound to the user in its client certificate.</p>
<h2 id="kubelet-x509-cert-distribution">kubelet x509 cert distribution</h2>
<p>Kubelet&rsquo;s x509 server certificates and client certificates can be issued by the controller manager using CSR (see <a href="(https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)">K8s Doc: Certificates and Certificate Signing Requests</a> and <a href="https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/">K8s Doc: Kubelet TLS bootstrapping</a>). They&rsquo;re issued by the controller manager.</p>
<p>👻 That&rsquo;s why the controller manager have start options below</p>
<pre><code>--cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt 
--cluster-signing-key-file=/etc/kubernetes/pki/ca.key
</code></pre>
<h2 id="3rd-application-requests-kubelet">3rd application requests kubelet</h2>
<div class="mermaid">flowchart LR

3rd-app --> |serviceaccount token| kubelet

kubelet <--> |authn| kube-apiserver
kubelet <--> |authz| kube-apiserver
</div>
<p>Third-party application can visit kubelet HTTPS server with service account token.
In this case kubelet sends <a href="https://github.com/kubernetes/api/blob/5d126b39754e30ad9a9206307e95f569ffe887ec/authentication/v1/types.go#L52">authentication.k8s.io/TokenReview</a> to kube-apiserver for authn, and <a href="https://github.com/kubernetes/api/blob/5d126b39754e30ad9a9206307e95f569ffe887ec/authorization/v1/types.go#L31">authorization.k8s.io/SubjectAccessReview</a> for authz.</p>
<h2 id="kube-apiserver-as-a-front-proxy-kube-aggregation">kube-apiserver as a front proxy (kube-aggregation)</h2>
<div class="mermaid">flowchart LR

Request --> kube-apiserver
kube-apiserver --> |1.authn/authz| kube-apiserver

kube-apiserver --> |2.Headers<br/>X-Remote-User<br/>X-Remote-Group<br/>X-Remote-Extra-<_key_>| aggregated-apiserver

aggregated-apiserver --> |3.authn Request<br/>by Headers and client CA| aggregated-apiserver
aggregated-apiserver <--> |4-a.authz Request by<br/>SubjectAccessReview| kube-apiserver
aggregated-apiserver <-.-> |4-b.authz Request<br/>itself| aggregated-apiserver
</div>
<p>The kube-apiserver provides several aggregation authentication options:</p>
<ul>
<li><code>proxy-client-cert-file</code> and <code>proxy-client-key-file</code> configure the credentials used when acting as a client/aggregator/front-proxy</li>
<li><code>requestheader-client-ca-file</code> and <code>requestheader-allowed-names</code> configure the CA and list of client certificate common names that the aggregated apiserver uses to verify the aggregator server (usually kube-apiserver). These are synced to the ConfigMap extension-apiserver-authentication in the kube-system namespace when the kube-apiserver starts up.</li>
</ul>
<p>The aggregated 3rd party apiservers can read authentication configurations from the <code>kube-system/extension-apiserver-authentication</code> ConfigMap.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--proxy-client-cert-file string             ---------------------------------------+
</span></span><span class="line"><span class="cl">  x509 cert used to prove the identity when work as aggregator<span class="o">(</span>front-proxy<span class="o">)</span>        <span class="p">|</span>-&gt; used by kube-aggregator <span class="o">(</span>
</span></span><span class="line"><span class="cl">--proxy-client-key-file string              ---------------------------------------+    module in kube-apiserver<span class="o">)</span>
</span></span><span class="line"><span class="cl">  x509 private key used to prove the identity when work as aggregator<span class="o">(</span>front-proxy<span class="o">)</span>           
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--requestheader-client-ca-file string       --------------------------------+---+
</span></span><span class="line"><span class="cl">  CA bundle used to verify client certificates on incoming requests when    +---<span class="p">|</span>--&gt; used to verify aggregator 
</span></span><span class="line"><span class="cl">    work as aggregated-apiserver                                            <span class="p">|</span>   <span class="p">|</span>     server<span class="err">&#39;</span>s client certificate
</span></span><span class="line"><span class="cl">--requestheader-allowed-names strings       --------------------------------<span class="p">|</span>   <span class="p">|</span>   
</span></span><span class="line"><span class="cl">  List of client certificate common names allowed to work as aggregator         +-&gt; used by aggregated apiserver
</span></span><span class="line"><span class="cl">--requestheader-username-headers string     ---------------------------------+  <span class="p">|</span>    configured in kube-apiserver   
</span></span><span class="line"><span class="cl">  List of request headers to inspect <span class="k">for</span> usernames. X-Remote-User is common  <span class="p">|</span>  <span class="p">|</span>    synced to ConfigMap            
</span></span><span class="line"><span class="cl">--requestheader-group-headers               ---------------------------------<span class="p">|</span>  <span class="p">|</span>      
</span></span><span class="line"><span class="cl">  List of request headers to inspect <span class="k">for</span> groups. X-Remote-Group is suggested +--<span class="p">|</span>--&gt; HTTP header key used to
</span></span><span class="line"><span class="cl">--requestheader-extra-headers-prefix        ---------------------------------+  <span class="p">|</span>     <span class="nb">read</span> user info from
</span></span><span class="line"><span class="cl">  List of request header prefixes to inspect. X-Remote-Extra- is suggested -----+         
</span></span></code></pre></td></tr></table>
</div>
</div><p>Firstly The aggregated-apiserver use the CA (configured by <code>requestheader-client-ca-file</code>) and <code>requestheader-allowed-names</code> to verify that the incoming request is from a valid kube-aggregator.</p>
<p>Then, the aggregated-apiserver authenticates the proxied request by mapping the headers <code>X-Remote-User</code>, <code>X-Remote-Group</code> and <code>X-Remote-Extra-&lt;key&gt;</code> to the user.</p>
<p>Finally, the aggregated-apiserver authorizes the proxied request:</p>
<ul>
<li>by delegating it to the kube-apiserver if it doesn&rsquo;t implement authority control (as many 3rd party apiservers do)</li>
<li>by authorizing it itself. The aggregated-apiserver can also be an apiserver that works as an authority.</li>
</ul>
<p>In practice, any component in the cluster could leverage the front-proxy authentication strategy.
The authentication configuration of kube-controller-manager or kube-scheduler has these <strong>requestheader-</strong> options.</p>
<h2 id="service-account">service account</h2>
<p>For service accounts, the kube-apiserver options are:</p>
<pre><code>--service-account-key-file stringArray 
    PEM-encoded x509 RSA or ECDSA private or public keys, used to verify ServiceAccount tokens
--service-account-signing-key-file string
    current private key of the service account token issuer
--service-account-issuer stringArray 
    Identifier of the service account token issuer
    The issuer will assert this identifier in &quot;iss&quot; claim of issued tokens
</code></pre>
<p>A client sends a <code>POST /api/v1/namespaces/{ns}/serviceaccounts/{sa}/token</code>request. The API server generates a service account token and signs the token using the private key of the service account token issuer. A TokenRequest containing the token is returned.</p>
<p>As API requests come in with the service account token, the kube-apiserver verifies the token in authentication with the public key of the service account token issuer.</p>
<p>Service account tokens issued by the API server are short-lived Kubernetes tokens. They are never persisted and can only be revoked by deleting their service account.</p>
<p>kube-controller-manager options</p>
<pre><code>--root-ca-file  root certificate authority will be included in service account's token secret.
--service-account-private-key-file
</code></pre>
<p>The controller manager generate service account token and sign the token using the private key of the service account token issuer.</p>
<p>The token&rsquo;s issuer is <code>kubernetes/serviceaccount</code>. The <code>root-ca-file</code> generally is the cluster CA.</p>
<p>The token and root CA both included in service account&rsquo;s token secret.</p>
<p>After v1.25, Kubernetes won&rsquo;t auto generate token secret for service account.</p>
<p>Service account tokens issued by the controller manager are so-called long-lived Kubernetes tokens. It can be revoked by delete their secret object.</p>
<p>Example of service account token issued by kube-apiserver</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;aud&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;https://kubernetes.default.svc.cluster.local&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="p">],</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;exp&#34;</span><span class="p">:</span> <span class="mi">1720539011</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;iat&#34;</span><span class="p">:</span> <span class="mi">1689003011</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;iss&#34;</span><span class="p">:</span> <span class="s2">&#34;https://kubernetes.default.svc.cluster.local&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;kubernetes.io&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;namespace&#34;</span><span class="p">:</span> <span class="s2">&#34;default&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;serviceaccount&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;default&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;uid&#34;</span><span class="p">:</span> <span class="s2">&#34;fcd19abf-938f-4485-9bf5-701d04137ffc&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;nbf&#34;</span><span class="p">:</span> <span class="mi">1689003011</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;sub&#34;</span><span class="p">:</span> <span class="s2">&#34;system:serviceaccount:default:default&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="mtls-between-etcd-and-kube-apiserver">mTLS between etcd and kube-apiserver</h2>
<p>There are kube-apiserver command line arguments about secure communication with etcd</p>
<pre><code>--etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt 
--etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt 
--etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key
</code></pre>
<p>These etcd command line arguments about secure communication with its client</p>
<pre><code>--trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt
--cert-file=/etc/kubernetes/pki/etcd/server.crt
--key-file=/etc/kubernetes/pki/etcd/server.key
</code></pre>
<p>The API server requests etcd with client x509 certificate and key, the etcd server validates the crenditial with <code>trusted-ca-file</code>.
Conversely, the API server validates etcd&rsquo;s server x509 certificate and key with <code>etcd-cafile</code>.</p>
<p>Note: <code>etcd-cafile</code> used by kube-apiserver and <code>trusted-ca-file</code> used by etcd server don&rsquo;t need to be the same.
`</p>
<h2 id="summarize">Summarize</h2>
<p>Here are the summary of the API server&rsquo;s command line arguments to do with certificates or keys</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--cert-dir string                 -------------+
</span></span><span class="line"><span class="cl">--tls-cert-file string                         <span class="p">|</span>
</span></span><span class="line"><span class="cl">--tls-private-key-file string                  +--&gt; serve securely on HTTPS
</span></span><span class="line"><span class="cl">--tls-sni-cert-key namedCertKey                <span class="p">|</span>
</span></span><span class="line"><span class="cl">  <span class="o">(</span>SNI certs, alternative to tls-cert<span class="o">)</span> --------+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--client-ca-file string    --------------------&gt; x509 CA authenticate client requests
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--etcd-certfile string     --------------------+                   
</span></span><span class="line"><span class="cl">--etcd-keyfile string                          +--&gt; mTLS with etcd server
</span></span><span class="line"><span class="cl">--etcd-cafile string       --------------------+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--kubelet-certificate-authority string --------+     
</span></span><span class="line"><span class="cl">--kubelet-client-certificate string            +--&gt; mTLS with kubelet
</span></span><span class="line"><span class="cl">--kubelet-client-key string            --------+
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">--proxy-client-cert-file string        --------+     
</span></span><span class="line"><span class="cl">--proxy-client-key-file string                 <span class="p">|</span> 
</span></span><span class="line"><span class="cl">                                               <span class="p">|</span>
</span></span><span class="line"><span class="cl">--requestheader-client-ca-file string          +--&gt; aggregation TLS
</span></span><span class="line"><span class="cl">--requestheader-allowed-names strings          <span class="p">|</span>      prove requests proxied from kube-aggregator
</span></span><span class="line"><span class="cl">--requestheader-extra-headers-prefix strings   <span class="p">|</span>
</span></span><span class="line"><span class="cl">--requestheader-group-headers strings          <span class="p">|</span>
</span></span><span class="line"><span class="cl">--requestheader-username-headers strings  -----+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--service-account-key-file stringArray     ----+ 
</span></span><span class="line"><span class="cl">--service-account-signing-key-file string  ----+--&gt; service account key pair   
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here are the summary of the controller-manager</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">--cluster-signing-cert-file string   ---+--&gt; CSR <span class="o">(</span>Certificate Signing Requests<span class="o">)</span> signing controller flags       
</span></span><span class="line"><span class="cl">--cluster-signing-key-file string    ---+          
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--root-ca-file string                ---+--&gt; issue long-lived service account token in secret                      
</span></span><span class="line"><span class="cl">--service-account-private-key-file   ---+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--client-ca-file                     ---&gt; authn requests by x509 client cert
</span></span><span class="line"><span class="cl">--requestheader-*                    ---&gt; authn requests by front-proxy requestheaders
</span></span><span class="line"><span class="cl">--authentication-kubeconfig          ---&gt; delegate authn to kube-apiserver
</span></span><span class="line"><span class="cl">--authorization-kubeconfig           ---&gt; delegate authz to kube-apiserver
</span></span></code></pre></td></tr></table>
</div>
</div><p>The scheduler&rsquo;s arguments to do with certificates are like the controller manager, but only about authn and authz.</p>
<p>Here are the summary of the kubelet</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">apiVersion: kubelet.config.k8s.io/v1beta1    
</span></span><span class="line"><span class="cl">kind: KubeletConfiguration
</span></span><span class="line"><span class="cl">authentication:                             --------------------+
</span></span><span class="line"><span class="cl">  anonymous:                                                    <span class="p">|</span>
</span></span><span class="line"><span class="cl">    enabled: <span class="nb">false</span>                                              <span class="p">|</span>
</span></span><span class="line"><span class="cl">  webhook:                                                      <span class="p">|</span>
</span></span><span class="line"><span class="cl">    enabled: <span class="nb">true</span>                                               + authn/authz strategies
</span></span><span class="line"><span class="cl">  x509:                                                         <span class="p">|</span>
</span></span><span class="line"><span class="cl">    clientCAFile: /etc/kubernetes/pki/ca.crt <span class="c1"># --client-ca-file |</span>
</span></span><span class="line"><span class="cl">authorization:                                                  <span class="p">|</span>
</span></span><span class="line"><span class="cl">  mode: Webhook                                                 <span class="p">|</span>
</span></span><span class="line"><span class="cl">rotateCertificates: <span class="nb">true</span>                    --------------------+
</span></span><span class="line"><span class="cl">---
</span></span><span class="line"><span class="cl">--bootstrap-kubeconfig             --------+
</span></span><span class="line"><span class="cl">--cert-dir  <span class="c1"># default /var/lib/kubelet/pki +--&gt; server/client x509 certs dynamic issue from CSR          </span>
</span></span><span class="line"><span class="cl">--tls-cert-file                            <span class="p">|</span>
</span></span><span class="line"><span class="cl">--tls-private-key-file             --------+
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="furthur-reading">Furthur Reading</h2>
<ol>
<li><a href="https://kubernetes.io/docs/concepts/security/controlling-access/">K8s Doc: Controlling Access to the Kubernetes API</a></li>
<li><a href="https://jvns.ca/blog/2017/08/05/how-kubernetes-certificates-work/">Julia Evans: How Kubernetes certificate authorities work</a></li>
<li><a href="https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/04-certificate-authority.md">Kubernetes The Hard Way</a></li>
<li><a href="https://kubernetes.io/docs/setup/best-practices/certificates/">K8s Doc: PKI certificates and requirements</a></li>
<li><a href="(https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)">K8s Doc: Certificates and Certificate Signing Requests</a></li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/">K8s Doc: Kubelet TLS bootstrapping</a></li>
<li><a href="https://kubernetes.io/docs/concepts/architecture/control-plane-node-communication/">K8s Doc: Communication between Nodes and the Control Plane</a></li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">K8s Doc: Authenticating</a></li>
<li><a href="https://learnk8s.io/authentication-kubernetes">User and workload identities in Kubernetes</a></li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/">K8s Doc: Authorization Overview</a></li>
<li><a href="https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/">K8s Doc: Kubelet authentication/authorization</a></li>
<li><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/">K8s Doc: Kubernetes API Aggregation Layer</a></li>
<li><a href="../2023-k8s-apiserver-aggregation-internals">搞懂 K8s apiserver aggregation</a></li>
<li><a href="https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-bound-service-account-tokens">What GKE users need to know about Kubernetes&rsquo; new service account tokens</a></li>
</ol>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Zeng Xu</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-06-03 16:13
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content">本作品采用 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a> 进行许可，转载时请注明原文链接。</span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kubernetes/">kubernetes</a>
          <a href="/tags/mtls/">mtls</a>
          <a href="/tags/ssl/">ssl</a>
          <a href="/tags/auth/">auth</a>
          <a href="/tags/x509/">x509</a>
          <a href="/tags/en/">en</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-the-docker-mtu-problem/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">虚拟网络环境中 Docker MTU 问题及解决方式</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-gen-self-signed-certificate/">
            <span class="next-text nav-default">Generate Self-Signed Certificate</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitalk = new Gitalk({
        id: '2022-08-01 16:13:12 \u002b0800 CST',
        title: 'K8s Internal Authentication\/Authorization and mTLS',
        clientID: '6ab3c721bb197ea92f1e',
        clientSecret: '217d38cc1905f60f1d963c555be606ed3e707937',
        repo: 'phosae.github.io',
        owner: 'phosae',
        admin: ['phosae'],
        body: decodeURI(location.href)
      });
      gitalk.render('gitalk-container');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zenngxu@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/phosae" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/u/1566013967" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://www.zeng.dev/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>Zeng Xu</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-FEPN2KZF84"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-FEPN2KZF84', { 'anonymize_ip': false });
}
</script>






<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>





</body>
</html>
